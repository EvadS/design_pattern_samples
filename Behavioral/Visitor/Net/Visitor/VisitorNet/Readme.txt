Как известно, нередко для разных категорий вкладчиков банки имеют свои правила: 
оформления вкладов, выдача кредитов, начисления процентов и т.д. Соответственно классы, описывающие
данные объекты, тоже будут разными. Но что важно, как правило, правила обслуживания четко описает
весь набор категорий клиентов. Например, есть физические лица, есть юридические, отдельные правила
для индивидуальных или частных предпринимателей и т.д. Поэтому структура классов, представляющая 
клиентов будет относительно фиксированной, то есть не склонной к изменениям.

И допустим, в какой-то момент мы решили добавить в классы клиентов функционал сериализации в html.

Для этого вводим метод ToHtml(), который создает таблицу со значениями этих свойств.
Но допустим, мы решили добавить потом еще сериализацию в формат xml. Задача относительно проста:
добавить  новый метод ToXml() и реализовать его в классах .

Но еще через некоторое время мы захотим добавить сериализацию в формат json.
Однако в будущем могут появиться новые форматы, которые мы также захотим поддерживать.
Частое внесение изменение в фиксированную структуру классов в данном случае не будет оптимально.

В роли абстрактного класса Element здесь выступает интерфейс IAccount. Однако его реализации теперь 
не содержат метод ToHtml(), и любой другой метод для сериализации в какой-либо формат. Так как вся
функциональность по сериализации вынесена в отдельные классы посетителей. В итоге классы Person и 
Company становятся намного чище и проще по структуре.

если нам надо добавить новый способ сериализации, достаточно просто определить еще один класс
посетителя.